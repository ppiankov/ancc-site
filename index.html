<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ANCC — Agent-Native CLI Convention</title>
  <meta name="description" content="A pattern for building CLI tools that AI agents can discover, install, and compose without plugins.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0E1116;
      color: #CDD6E0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
      line-height: 1.7;
      padding: 2rem 1.5rem;
      max-width: 640px;
      margin: 0 auto;
    }
    h1 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.25rem; }
    h2 { font-size: 1.1rem; font-weight: 600; margin-top: 2.5rem; margin-bottom: 0.5rem; }
    p { margin-bottom: 1rem; color: #CDD6E0; }
    a { color: #CDD6E0; }
    .meta { color: #7C8590; font-size: 0.85rem; margin-bottom: 2rem; }
    .section-intro { color: #7C8590; font-size: 0.9rem; margin-bottom: 1.25rem; }
    .requirement { margin-bottom: 1.5rem; }
    .requirement-name { font-weight: 600; }
    .requirement-desc { color: #7C8590; font-size: 0.9rem; margin-top: 0.2rem; }
    .tool { margin-bottom: 1.5rem; }
    .tool-name { font-weight: 600; text-decoration: none; border-bottom: 1px solid #3B414A; }
    .tool-name:hover { border-bottom-color: #7C8590; }
    .tool-desc { color: #7C8590; font-size: 0.9rem; margin-top: 0.2rem; }
    pre {
      background: #161B22;
      border: 1px solid #3B414A;
      border-radius: 4px;
      padding: 1rem;
      overflow-x: auto;
      font-size: 0.82rem;
      line-height: 1.5;
      margin-bottom: 1rem;
      color: #CDD6E0;
    }
    code { font-family: "SF Mono", "Fira Code", "Fira Mono", Menlo, Consolas, monospace; font-size: 0.85rem; }
    .inline-code { background: #161B22; padding: 0.15rem 0.35rem; border-radius: 3px; font-size: 0.82rem; }
    .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem; }
    .comparison-col h3 { font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; }
    .comparison-col ul { list-style: none; padding: 0; }
    .comparison-col ul li { color: #7C8590; font-size: 0.85rem; margin-bottom: 0.3rem; padding-left: 1.2rem; position: relative; }
    .comparison-col ul li::before { position: absolute; left: 0; }
    .comparison-col.before ul li::before { content: "\00d7"; color: #7C8590; }
    .comparison-col.after ul li::before { content: "\2192"; color: #CDD6E0; }
    .links { margin-top: 3rem; color: #7C8590; font-size: 0.9rem; }
    .links a { color: #7C8590; margin-right: 1.5rem; }
    @media (max-width: 480px) { .comparison { grid-template-columns: 1fr; } }
  </style>
</head>
<body>

  <h1>ANCC</h1>
  <p class="meta">Agent-Native CLI Convention. Build tools agents can use without plugins.</p>

  <p>ANCC is a pattern for building CLI tools that agents can discover, install, configure, and compose. "Agent" here means any autonomous process with shell access — an LLM in a loop, a CI pipeline, a cron job. When a tool is deterministic and its interface is documented, the agent doesn't need to guess. It reads the spec, runs the command, parses the output.</p>

  <h2>Tools</h2>
  <p class="section-intro">Tools following this pattern.</p>

  <div class="tool">
    <a class="tool-name" href="https://github.com/ppiankov/chainwatch">chainwatch</a>
    <p class="tool-desc">AI agent execution control plane. Watch, contain, and audit autonomous agent runs.</p>
  </div>

  <div class="tool">
    <a class="tool-name" href="https://github.com/ppiankov/noisepan">noisepan</a>
    <p class="tool-desc">Signal extractor for noisy information streams.</p>
  </div>

  <div class="tool">
    <a class="tool-name" href="https://github.com/ppiankov/entropia">entropia</a>
    <p class="tool-desc">Source credibility verifier.</p>
  </div>

  <h2>Observed in practice</h2>
  <p class="section-intro">An autonomous agent encountered these tools and installed them without a plugin.</p>

  <p>Given a goal and access to a shell, an agent discovered CLI tools from conversation context. It ran <span class="inline-code">brew install ppiankov/tap/noisepan</span>, then <span class="inline-code">noisepan init</span> to generate a config file, edited the config for its task, and executed <span class="inline-code">noisepan pull --format json</span>. When asked to upgrade the pipeline, the agent ran <span class="inline-code">noisepan doctor</span> and discovered entropia as a companion tool for source verification — then installed it too. No plugin framework. No SDK. No registry.</p>

  <h2>Why it matters</h2>
  <p class="section-intro">Concrete friction reduction.</p>

  <div class="comparison">
    <div class="comparison-col before">
      <h3>Without ANCC</h3>
      <ul>
        <li>Agents guess flags from help text</li>
        <li>Agents parse human-readable output</li>
        <li>Agents hallucinate usage patterns</li>
        <li>Install requires runtimes or containers</li>
        <li>No way to know what a tool won't do</li>
        <li>No discovery of companion tools</li>
      </ul>
    </div>
    <div class="comparison-col after">
      <h3>With ANCC</h3>
      <ul>
        <li>Agent reads SKILL.md</li>
        <li>Runs <span class="inline-code">init</span>, gets valid config</li>
        <li>Uses <span class="inline-code">--format json</span></li>
        <li>Exit code defines result</li>
        <li>Contract is explicit</li>
        <li><span class="inline-code">doctor</span> surfaces companion tools</li>
      </ul>
    </div>
  </div>

  <h2>The Convention</h2>
  <p class="section-intro">Six requirements. A tool that meets all six is agent-native.</p>

  <div class="requirement">
    <p class="requirement-name">1. Single binary, zero runtime deps</p>
    <p class="requirement-desc">Ship one binary. Install means copy a file. Homebrew, <span class="inline-code">curl | tar</span>, or <span class="inline-code">go install</span>. An agent that can run shell commands can install it.</p>
  </div>

  <div class="requirement">
    <p class="requirement-name">2. Deterministic behavior</p>
    <p class="requirement-desc">Same input, same output. No ambient state, no implicit config. Running <span class="inline-code">tool analyze input.txt --format json</span> twice produces identical output unless the input changes. An agent can verify its work by running the command again.</p>
  </div>

  <div class="requirement">
    <p class="requirement-name">3. Structured output</p>
    <p class="requirement-desc">Support <span class="inline-code">--format json</span> for machine consumption. Human-readable output is the default. JSON output is the agent interface.</p>
  </div>

  <div class="requirement">
    <p class="requirement-name">4. One bounded job</p>
    <p class="requirement-desc">Each tool does one thing. It runs, produces output, and exits. No interactive modes. If a service or daemon exists, it is controlled through bounded CLI commands — the ANCC interface is always a single invocation with a defined exit.</p>
  </div>

  <div class="requirement">
    <p class="requirement-name">5. SKILL.md at repo root</p>
    <p class="requirement-desc">A machine-readable file that tells an agent everything it needs: how to install, what commands exist, what flags they take, what the JSON output looks like, and what the tool does not do.</p>
  </div>

  <div class="requirement">
    <p class="requirement-name">6. Init command</p>
    <p class="requirement-desc">Running <span class="inline-code">tool init</span> produces a valid config file with sensible defaults. An agent runs init, reads the result, and adjusts from there.</p>
  </div>

  <h2>Recommended: Doctor command</h2>
  <p class="section-intro">Not required, but powerful for tools that compose with others.</p>

  <p>Running <span class="inline-code">tool doctor</span> checks the tool's own health — config validity, dependencies, connectivity — and surfaces companion tools it can compose with. An agent runs doctor to understand what's working, what's missing, and what else to install. Tools that operate in isolation don't need this. Tools that form pipelines benefit from it.</p>

  <h2>SKILL.md</h2>
  <p class="section-intro">The interface contract. Lives at the repo root.</p>

  <p>SKILL.md is what makes a tool discoverable. An agent reads it to learn what a tool does, how to install it, and how to parse its output. A single markdown file that works for humans and machines.</p>

  <pre><code># tool-name

One-line description of what this tool does.

## Install

```
brew install user/tap/tool-name
```

## Commands

### tool-name analyze

Analyzes input and produces a report.

**Flags:**
- `--format json` — output as JSON (default: human-readable)
- `--config path` — config file (default: ./tool-name.yaml)
- `--verbose` — show detailed progress

**JSON output:**
```json
{
  "status": "pass | fail | warn",
  "score": 0.0-1.0,
  "details": [{"item": "...", "result": "..."}]
}
```

**Exit codes:**
- 0: success
- 1: failure (bad input, missing config)
- 2: partial results (some checks passed)

## What this does NOT do

- Does not modify input files
- Does not make network requests unless configured
- Does not require authentication for local operation

## Parsing examples

```bash
# Get the status
tool-name analyze --format json | jq '.status'

# Filter failing items
tool-name analyze --format json | jq '.details[] | select(.result == "fail")'
```</code></pre>

  <h2>Principle</h2>

  <p>ANCC names a pattern that already works. Tools present evidence and let you decide. The terminal worked before agents, and it works with them.</p>

  <div class="links">
    <a href="https://github.com/ppiankov/ancc-site">GitHub</a>
  </div>

</body>
</html>
